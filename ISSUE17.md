# Aggregate Beacon Protocol Exploration

## Introduction  

The SMTAggregate and CIDAggregate *Beacons* in the **did:btc1** method require a cohort of *n* DID controllers to coordinate on creating an *n-of-n* MuSig (multi-signature) Taproot address and jointly authorizing Bitcoin transactions (Beacon signals). This entails a multi-party threshold signature workflow (e.g. MuSig2 or FROST) where participants must exchange keys, commitments, and signatures. The communication channel must support decentralized coordination, secure message exchange, asynchronous (offline) message delivery, and robustness against interference or surveillance. Six key attributes are critical in evaluating candidate protocols:

1. **Privacy & Encryption** – Does the channel ensure message confidentiality (end-to-end encryption) and participant anonymity or metadata protection?  
2. **Authenticity & Signatures** – Can participants verify the origin and integrity of messages (e.g. cryptographic signatures, identity binding)?  
3. **Censorship Resistance** – How difficult is it for an adversary or intermediary to block, censor, or tamper with the communication?  
4. **Scalability & Performance** – Can the protocol handle the load of multi-round signing exchanges efficiently (latency, throughput) for possibly many Beacon updates or participants?  
5. **Self-Sovereignty & Openness** – Does the solution avoid centralized control, and is it based on open standards that anyone can implement and use without gatekeepers?  
6. **Ease of Implementation** – How complex is it to integrate and deploy the protocol for DID controller coordination (considering existing libraries, infrastructure requirements, and developer effort)?

We compare five communication approaches against these criteria: **REST/HTTPS APIs**, **Nostr**, **DIDComm**, **Lightning Network Onion Messages**, and **Self-Hosted channels (IRC/Matrix via Tor)**. Below we evaluate each in detail, then summarize with a comparison table and recommend the best fit for **did:btc1** Beacons.

## Protocol Evaluations

### REST (HTTPS APIs)  

Using a traditional RESTful web service (over HTTPS) is a straightforward approach to exchanging JSON messages between participants. Each DID controller (or a designated coordinator server) would expose API endpoints for others to call.

- **Privacy & Encryption:** Communication is encrypted in transit via TLS, but not end-to-end – the server handling the REST requests can see the plaintext unless additional application-layer encryption is applied. Confidentiality thus relies on trusting the server or implementing custom encryption of payloads. Also, HTTPS doesn’t hide metadata like domain names or IPs, so observers could potentially identify who is communicating ([Internet censorship - Wikipedia](https://en.wikipedia.org/wiki/Internet_censorship#:~:text=The%20use%20of%20HTTPS%20does,depends%20on%20both%20client%20and)). In summary, transport security is strong, but true E2E privacy is **not inherent** without extra measures.  
- **Authenticity & Signatures:** HTTPS ensures the authenticity of the server (via certificates) but not of the clients or the content. There is no built-in mechanism for message signing by the DID controllers. Participants would need to sign payloads with their own keys for end-to-end authenticity. This is feasible (they *could* sign each message or use the threshold signing keys for verification), but it’s an extra step beyond what REST provides by default. Without such measures, a malicious server or MITM could alter messages.  
- **Censorship Resistance:** **Low.** REST/HTTP is vulnerable to simple blocking or takedown. Service depends on DNS entries and centralized hosting. Adversaries or authorities can block a known server’s IP or domain, or compel the host to censor or log traffic. As the EFF notes, HTTPS by itself doesn’t prevent a determined censor from denying access to a given domain ([Internet censorship - Wikipedia](https://en.wikipedia.org/wiki/Internet_censorship#:~:text=The%20use%20of%20HTTPS%20does,depends%20on%20both%20client%20and)). Unless all participants self-host and perhaps use anonymizing networks, a REST API can be a single point of failure.  
- **Scalability & Performance:** **High for small groups.** Web servers and HTTP requests can handle moderate loads with low latency. The overhead per message is small (an HTTP POST with JSON). For an *n-of-n* signing round, each participant could POST their commitments and signatures to a coordinator or to each other. This is manageable for small *n*. However, if many DID operations or many independent Beacon cohorts run concurrently, a centralized server could become a bottleneck. Generally, HTTP scales well vertically (with stronger servers) or via load balancers, so performance is not a major concern here.  
- **Self-Sovereignty & Openness:** **Moderate to Low.** REST itself is an open web standard, but using it typically introduces centralized elements – e.g. a coordinator server or reliance on DNS and Certificate Authorities. Each controller could run their own endpoint (achieving a degree of decentralization), but then every other participant must know how to reach it (which often means a static domain or IP – often centrally managed). Without centralized directories or DNS, pure peer-to-peer REST is hard. In practice, one might end up with one controller acting as a hub (not self-sovereign for others), or using existing cloud infrastructure. Overall, while anyone *can* run a REST service, the coordination pattern is not peer-to-peer by default, and it doesn’t inherently align with decentralized identity ideals.  
- **Ease of Implementation:** **High.** Implementing a REST API is very familiar to developers. There are countless frameworks for building HTTP+JSON services, and clients can use simple libraries (cURL, axios, etc.). Exchanging keys and signatures as JSON is straightforward. This simplicity is a big advantage – minimal new technology learning is required. However, developers would still need to implement extra layers for things like message signing/verification and perhaps a database or in-memory store to support offline retrieval of messages. Handling NAT traversal or dynamic endpoints is also non-trivial if not using a fixed server.

**Summary:** REST/HTTPS offers ease and baseline security (TLS), but falls short on decentralization and censorship resistance. It would require additional encryption and signature handling to meet the strict security requirements, and likely relies on at least one stable server endpoint, introducing a potential point of failure or control.

### Nostr  

**Nostr** is a decentralized messaging protocol built around a distributed network of relays and cryptographic keys. Originally designed for censorship-resistant social networking, it has emerged as a general-purpose message bus. Each user has a keypair (pubkey as an ID), signs all messages (“events”), and publishes them to relays. Peers subscribe to relays to receive events. Nostr can support direct end-to-end encrypted messages (via shared secret between pubkeys) and is known for its strong resistance to censorship ([Nostr, a simple protocol for decentralizing social media that has a chance of working](https://nostr.com/#:~:text=Nostr%20is%20a%20simple%2C%20open,resistant%20social%20media)) ([Nostr, a simple protocol for decentralizing social media that has a chance of working](https://nostr.com/#:~:text=Resilient)).

- **Privacy & Encryption:** By default, Nostr events are public to any relay subscriber, but *kind 4* (direct message) events are end-to-end encrypted so that only the intended recipient can decrypt the content ([The Nostr Privacy Paradox](https://bitcoinmagazine.com/technical/how-nostr-can-improve-bitcoin-privacy#:~:text=Instead%20of%20using%20notification%20transactions,through%20the%20avoidance%20of%20toxic)). For group coordination (multiple recipients), Nostr now defines a group chat event type (kind 14) that allows a message encrypted for multiple specific pubkeys ([nips/17.md at master · nostr-protocol/nips · GitHub](https://github.com/nostr-protocol/nips/blob/master/17.md#:~:text=Kind%20,more%20receivers%20of%20the%20message)) ([nips/17.md at master · nostr-protocol/nips · GitHub](https://github.com/nostr-protocol/nips/blob/master/17.md#:~:text=Kind%20,relays%20and%20become%20fully%20public)). This means Beacon participants could exchange encrypted messages that are stored by relays but unreadable to them or any eavesdropper without the private keys. In addition to content encryption, Nostr provides *pseudonymity*: users are identified by public keys (usually presented as npub... strings) with no inherent link to real-world identity. The network itself doesn’t reveal IP addresses to recipients – clients connect to relays over TLS or Tor. However, relay operators and network observers *could* see IP metadata unless users connect via Tor or other privacy tools. Overall, Nostr can provide **strong content privacy** (with E2EE for messages) and **decentralized storage** (multiple relays) to mitigate metadata leakage.  
- **Authenticity & Signatures:** **Excellent.** Every Nostr message (event) is cryptographically signed by the sender’s private key ([Nostr - Wikipedia](https://en.wikipedia.org/wiki/Nostr#:~:text=protocol%20achieves%20decentralization%20through%20users,3)) ([Nostr, a simple protocol for decentralizing social media that has a chance of working](https://nostr.com/#:~:text=Resilient)). Recipients automatically verify the signature to ensure the event was indeed produced by the claimed pubkey and not tampered with. This provides non-repudiation and integrity: a Beacon participant’s messages are verifiably theirs. In the context of threshold signing, this means each partial signature or key share broadcast via Nostr would be tied to a specific controller’s key. The Nostr pubkeys of the DID controllers could even be listed or agreed upon beforehand (e.g., in the DID Document or via an initial out-of-band exchange), ensuring only authorized cohort members’ messages are processed. Authenticity is **inherent** in Nostr’s design via signatures ([Nostr - Wikipedia](https://en.wikipedia.org/wiki/Nostr#:~:text=protocol%20achieves%20decentralization%20through%20users,3)).  
- **Censorship Resistance:** **Very High.** Nostr was explicitly created to route around censorship ([Nostr, a simple protocol for decentralizing social media that has a chance of working](https://nostr.com/#:~:text=Nostr%20is%20a%20simple%2C%20open,resistant%20social%20media)) ([Nostr: learn about the censorship-resistant “X”! - Area Bitcoin](https://blog.areabitcoin.co/nostr/#:~:text=Nostr%20is%20an%20open,and%20ensuring%20resistance%20to%20censorship)). There is no central server – anyone can run a relay, and users can publish to or fetch from many relays at once. Even if some relays refuse to carry certain content or ban certain keys, participants can find or run alternative relays that will carry their traffic. Because events are signed, a malicious relay cannot alter content without detection (it could only drop events). The protocol assumes relays may “disappear” or be unreliable, and encourages using multiple ([Nostr, a simple protocol for decentralizing social media that has a chance of working](https://nostr.com/#:~:text=Because%20Nostr%20doesn%27t%20rely%20on,they%20can%20change%20over%20time)). Users cannot be globally banned – at worst they are *inconvenienced* by needing to switch relays ([Nostr, a simple protocol for decentralizing social media that has a chance of working](https://nostr.com/#:~:text=Resilient)). This makes it extremely difficult for any adversary to censor coordination messages, especially if the cohort shares events over several relays (adding redundancy). Additionally, Nostr can be used over Tor or I2P for anonymity. The bottom line: as long as one honest relay is accessible (or a direct connection to one of the peers’ relays), messages will get through ([The Nostr Privacy Paradox](https://bitcoinmagazine.com/technical/how-nostr-can-improve-bitcoin-privacy#:~:text=Instead%20of%20using%20notification%20transactions,through%20the%20avoidance%20of%20toxic)). This distributed model meets the **censorship resistance** requirement handily.  
- **Scalability & Performance:** Nostr is designed to handle **global scale** social networking, so a small group of DID controllers exchanging periodic messages is well within its capacity. Messages are small (often <1 KB JSON including signature). Relays can handle thousands of events per second and store millions of events. In practice, coordination messages for MuSig/FROST would be sporadic and low-volume (a few rounds of a few kilobytes each). Latency is on the order of the relay round-trip: typically sub-second to a few seconds. This is sufficient for interactive signing. Nostr’s publish/subscribe model means a participant only needs to send a message once to a relay (or a few relays), and all others can fetch it, which is **bandwidth-efficient** for group messages. One consideration is that for privacy the group might use encrypted DMs (kind 4) which are one-to-one – requiring the sender to send N identical encrypted messages (one per recipient). This multiplies bandwidth slightly (n messages instead of 1), but given *n* is small and messages are short, it’s still trivial load. Upcoming Nostr improvements like group chats (kind 14) allow one message to multiple recipients with a single publish ([nips/17.md at master · nostr-protocol/nips · GitHub](https://github.com/nostr-protocol/nips/blob/master/17.md#:~:text=Kind%20,more%20receivers%20of%20the%20message)). In terms of asynchronous delivery, relays store events until clients fetch them, enabling offline participants to catch up later ([The Nostr Privacy Paradox](https://bitcoinmagazine.com/technical/how-nostr-can-improve-bitcoin-privacy#:~:text=The%20problem%3A%20PayJoin%20transactions%20are,By%20using%20Nostr%20keys%20instead)). The protocol thus **scales well** for our use case and provides near real-time performance when all parties are online.  
- **Self-Sovereignty & Openness:** **High.** Nostr is an open protocol (publicly specified, no proprietary control) and permissionless – “anyone can be a relay or a user” is a core principle ([Nostr, a simple protocol for decentralizing social media that has a chance of working](https://nostr.com/#:~:text=Nostr%20is%20a%20simple%2C%20open,resistant%20social%20media)) ([Nostr, a simple protocol for decentralizing social media that has a chance of working](https://nostr.com/#:~:text=Resilient)). Identity is self-sovereign: your Nostr keypair is generated and held by you, not issued by any authority. You don’t register an account; you simply create a key and start using it. If you don’t trust existing relays, you can run your own and even make it private for the cohort. There’s no dependency on DNS, CA infrastructure, or big tech providers. This aligns with DID principles of decentralization. Because content can be encrypted, using public relays does not compromise document privacy. Nostr’s design ensures no single entity controls the data flow, and participants have full control over their keys and can choose where their data is relayed. This **openness** has been a major selling point of Nostr (it’s often compared to HTTP or email in that anyone can implement it) ([Nostr, a simple protocol for decentralizing social media that has a chance of working](https://nostr.com/#:~:text=Resilient)) ([Nostr, a simple protocol for decentralizing social media that has a chance of working](https://nostr.com/#:~:text=messages%20were%20really%20sent%20by,the%20user%20in%20question)).  
- **Ease of Implementation:** **Moderate.** Nostr is relatively simple to integrate, especially given its growing popularity in the Bitcoin community. The protocol itself is just WebSocket connections sending JSON, and there are many client libraries available in Python, JavaScript, Rust, etc. Basic operations (connect to relay, publish event, subscribe for events) are straightforward. The DID controllers would need to incorporate a Nostr client component into their software. Handling keys and signing Nostr events is easy (it uses secp256k1 keys, which is convenient since Bitcoin and likely did:btc1 keys use the same curve). Indeed, controllers could even reuse their DID secp256k1 keys as Nostr keys, or derive a Nostr-specific key. On the flip side, setting up **group encryption** requires a bit of care – the cohort must ensure messages are encrypted such that only the intended members can read them. This could be done by encrypting individually to each member’s pubkey (which Nostr supports by default for DMs ([The Nostr Privacy Paradox](https://bitcoinmagazine.com/technical/how-nostr-can-improve-bitcoin-privacy#:~:text=Instead%20of%20using%20notification%20transactions,through%20the%20avoidance%20of%20toxic))) or using a shared symmetric key distributed at beacon setup. Such logic adds complexity, but libraries and NIPs (Nostr Improvement Proposals) are emerging to handle group chats securely. Compared to DIDComm, Nostr is lighter-weight – there’s no complex routing algorthims or envelope formats to implement, just signing and sending JSON. Many developers find Nostr integration easier than running a custom server or a full P2P overlay. Overall, implementing Nostr is a **reasonable effort** with ample community tooling available, but it is a newer technology so developers may need a learning curve if unfamiliar.

**Summary:** Nostr offers strong privacy (with encryption), built-in authenticity via signatures, unmatched censorship resistance, and a decentralized, store-and-forward network ideal for asynchronous coordination ([The Nostr Privacy Paradox](https://bitcoinmagazine.com/technical/how-nostr-can-improve-bitcoin-privacy#:~:text=The%20problem%3A%20PayJoin%20transactions%20are,By%20using%20Nostr%20keys%20instead)). It hits all the requirements and has growing mindshare in the Bitcoin/DID community. The main effort is ensuring proper encryption for group messages, but otherwise it aligns extremely well with the Beacon coordination needs.

### DIDComm  

**DIDComm V2** is a secure messaging protocol specifically designed for communication between Decentralized Identifier (DID) controllers (e.g., between agents or wallets). DIDComm messages are sent **peer-to-peer** using the keys and endpoints advertised in DIDs. Each message is packaged in a JWM (JSON Web Message) envelope, typically encrypted and authenticated for the recipients using keys from their DID Documents ([Guest Blog: DIDComm Demo](https://blog.identity.foundation/dif-guest-blog-didcomm-demo/#:~:text=DIDComm%20is%20short%20for%20DID,push%20notifications%2C%20and%20QR%20codes)). DIDComm supports **mediators** – intermediate agents that can store-and-forward messages for offline recipients ([Guest Blog: DIDComm Demo](https://blog.identity.foundation/dif-guest-blog-didcomm-demo/#:~:text=DIDComm%20doesn%E2%80%99t%20provide%20an%20inherent,to%20be%20stored%20and%20routed)). Essentially, DIDComm provides a way for DID controllers to communicate privately, authenticated, and asynchronously over any transport (HTTP, email, etc.), leveraging their decentralized identities.

- **Privacy & Encryption:** **Strong.** DIDComm is built around end-to-end encryption. Messages are encrypted at the sender’s side (using the recipient’s public key from their DID Document) and can only be decrypted by the intended recipient(s) ([Guest Blog: DIDComm Demo](https://blog.identity.foundation/dif-guest-blog-didcomm-demo/#:~:text=DIDComm%20is%20short%20for%20DID,push%20notifications%2C%20and%20QR%20codes)) ([Guest Blog: DIDComm Demo](https://blog.identity.foundation/dif-guest-blog-didcomm-demo/#:~:text=We%20used%20a%20chat%20window,and%20your%20data%20is%20secure)). This ensures that even if messages pass through intermediate servers or relays, the content remains confidential. DIDComm V2 uses modern cryptographic primitives (often X25519 for encryption and ED25519 for signatures by default, though it can work with secp256k1 if those keys are in the DIDs) to protect confidentiality and provide forward secrecy. In addition, DIDComm can be used over any transport – one could send DIDComm messages through Tor, email, Nostr, or HTTPS – adding flexibility in hiding traffic. The protocol’s focus is on private, point-to-point communication, which aligns with the need to exchange MuSig commitments or signature shares away from prying eyes. Thus, with DIDComm, the Beacon participants could exchange all necessary data (public keys, nonce commitments, partial signatures) fully encrypted at the message level.  
- **Authenticity & Signatures:** **Strong.** DIDComm messages can be authenticated using the sender’s DID keys. Typically, a DIDComm message is packed in either a **signed AND encrypted** form or just encrypted. If authenticity of the sender needs to be guaranteed, the sender can sign the message with their private key (which others can verify via the DID Document’s public key) before encrypting it. This provides cryptographic proof of who sent the message ([Guest Blog: DIDComm Demo](https://blog.identity.foundation/dif-guest-blog-didcomm-demo/#:~:text=DIDComm%20uses%20did%3Apeer2%20DIDs%20to,Demo%20app%20resolves%20the%20mediator%E2%80%99s)). Even without a separate signature, the encryption itself can provide authentication if done using a mutually authenticated scheme (e.g., Authcrypt in DIDComm establishes sender authenticity by using sender’s private key in the encryption process). In short, DIDComm was designed for **trustworthy communication**, ensuring you know who a message came from and that it wasn’t altered in transit. This meets the authenticity requirement nicely – each DID controller’s agent would only accept messages that verify against the expected DID keys. Non-repudiation is also achieved if messages are explicitly signed.  
- **Censorship Resistance:** **Moderate.** On its own, DIDComm is agnostic to transport, which means *censorship resistance depends on the transport chosen*. If DIDComm messages are sent via a centralized service endpoint (e.g., through a cloud mediator with a known URL), that mediator could be blocked or taken down, similar to a REST API. However, implementers can mitigate this. For example, peers could exchange DIDComm over Tor hidden services or over Nostr (using Nostr purely as a dumb pipe to carry the ciphertext). One can also use multiple mediators or fallback transports. The DIDComm protocol ensures that only the DID holder can read the message, so even if it passes through less trusted infrastructure, censorship is the main threat rather than content leakage. A creative approach could be to use a combination of transports: e.g., broadcast the DIDComm message over a public medium – since only the intended recipient can decrypt, a censor can’t easily tell which envelope is relevant to them. That said, compared to Nostr, DIDComm lacks a large decentralized relay network of its own. It often assumes a *service endpoint* in the DID Document (which could be a participant’s own server or a third-party mediator). If that endpoint is a single HTTP(S) URL, it’s subject to the usual blocking risks ([Internet censorship - Wikipedia](https://en.wikipedia.org/wiki/Internet_censorship#:~:text=The%20use%20of%20HTTPS%20does,depends%20on%20both%20client%20and)). The **upside** is that because DIDComm is just data, participants can agree on any routing to evade censorship (it’s flexible). In summary, DIDComm can be made censorship-resistant if layered on a resistant transport, but it does not *by itself* guarantee censorship avoidance. It’s as robust as the network path you choose (Tor, mesh networks, etc.). We’d rate this **medium** – not inherently as bulletproof as Nostr’s global relay mesh, but not tied to any central service either (DIDComm is fully peer-to-peer in concept) ([Guest Blog: DIDComm Demo](https://blog.identity.foundation/dif-guest-blog-didcomm-demo/#:~:text=Please%20explain%20the%20concept%20of,role%20in%20the%20DIDComm%20Demo)).  
- **Scalability & Performance:** DIDComm was designed for **efficient, asynchronous communication** between parties. Each message is a compact JSON or CBOR structure. However, the encryption and signature layers add some overhead (cryptographic envelope headers, base64 encoding). For a handful of participants, this overhead is negligible (message sizes on the order of a couple of kilobytes). The bigger consideration is that DIDComm is typically one-to-one or one-to-few: if you want to send a message to *n* participants, you might encrypt it *n* times (once per recipient) unless you use a multi-recipient envelope. DIDComm does support packing messages for multiple recipients in a single send, but it’s not as straightforward as a broadcast on a public relay. Still, a coordinator could loop to send the same payload to each controller’s DID endpoint. The latency would be that of sending *n* separate encrypted messages via the mediator or direct connections. If done sequentially this is slightly slower than a single broadcast, but with small n (say 3, 5, or even 10) it’s fine. In terms of **offline support**, DIDComm has the concept of **mediators** which buffer messages for later delivery ([Guest Blog: DIDComm Demo](https://blog.identity.foundation/dif-guest-blog-didcomm-demo/#:~:text=DIDComm%20doesn%E2%80%99t%20provide%20an%20inherent,to%20be%20stored%20and%20routed)). For example, a mobile wallet might use a cloud mediator that holds incoming DIDComm messages until the wallet comes online and fetches them ([Guest Blog: DIDComm Demo](https://blog.identity.foundation/dif-guest-blog-didcomm-demo/#:~:text=are%20cloud,to%20be%20stored%20and%20routed)). This is directly applicable to Beacon coordination: a mediator service (potentially run by one of the controllers or a neutral party) could queue MuSig round messages so that not all parties need to be online simultaneously. Performance-wise, the cryptographic operations (ECDH and signing) are fast and would not bottleneck the process. DIDComm can function in real time (e.g., for interactive credential exchange) with latency mainly determined by the network hops, similar to HTTPS. Thus, DIDComm can handle the interactive threshold signing flows without issue; it may be a bit more complex to orchestrate multi-party messages, but it’s capable.  
- **Self-Sovereignty & Openness:** **High.** DIDComm is an open standard under the Decentralized Identity Foundation and IETF, with community-driven specification. It is **made for self-sovereign identity** – participants use their own DIDs and keys, no central authorities are needed to mediate trust. Each DID Document can specify its own service endpoint and the keys it wants to use for communication, meaning each controller decides how they want to be reached. You can run your own mediator or choose one you trust; you can even have a direct peer-to-peer connection if reachable. There is no dependency on centralized services *unless you choose one* for convenience (and even then, messages are encrypted). Also, DIDComm doesn’t rely on internet-centralized infrastructure like DNS or PKI – it leverages the DID infrastructure (in this case, did:btc1 on Bitcoin) for key discovery, which is decentralized via the blockchain. All implementations interoperate through the open spec, ensuring no vendor lock-in. In short, DIDComm aligns perfectly with the **self-sovereign, decentralized ethos** – everyone is a peer with control over their identity keys ([Guest Blog: DIDComm Demo](https://blog.identity.foundation/dif-guest-blog-didcomm-demo/#:~:text=DIDComm%20is%20short%20for%20DID,push%20notifications%2C%20and%20QR%20codes)). The only caveat: to discover a DID’s service endpoint, one might need to resolve the DID (which for did:btc1 means reading the Bitcoin chain) – but that’s decentralized and permissionless by design.  
- **Ease of Implementation:** **Low to Moderate.** DIDComm’s power comes with complexity. Implementing it from scratch is non-trivial – one must handle constructing JWM envelopes, doing authenticated encryption, key resolution via DIDs, and following the protocols for message routing. However, there are existing libraries (e.g., DIF’s didcomm libraries in Rust, Kotlin, Python, etc., and the Hyperledger Aries framework). If a project is already using a DID stack or Aries agent, a lot of it is handled. But for a team starting fresh, **the learning curve is significant**. By their own admission, using DIDComm often meant using heavy agent frameworks (like ACA-Py), which is why simpler demos and libraries were created ([Guest Blog: DIDComm Demo](https://blog.identity.foundation/dif-guest-blog-didcomm-demo/#:~:text=The%20reason%20we%20wrote%20this,Py)). A did:btc1 implementer would need to integrate DID resolution (for did:btc1 to get controllers’ pubkeys and endpoints), and then a DIDComm library to send/receive messages. Setting up a mediator (if needed for offline) is another task – though one of the controllers or an existing DID hub could serve that role. Compared to something like Nostr or REST, the number of moving parts is greater. Additionally, debugging encrypted flows can be tricky. Nevertheless, the benefit is that once set up, DIDComm provides a *standardized* way to communicate securely. The effort might be justified if the ecosystem around did:btc1 expects integration with other DIDComm-capable agents. If not, it could feel like reinventing a complex wheel when simpler approaches exist. In summary, **implementation difficulty is medium-high**: it’s definitely doable (especially with available open-source libraries), but it’s more work than plugging into a WebSocket or HTTP API.

**Summary:** DIDComm delivers top-notch security (privacy and authenticity) and aligns with the DID-centric model of did:btc1 ([Guest Blog: DIDComm Demo](https://blog.identity.foundation/dif-guest-blog-didcomm-demo/#:~:text=DIDComm%20is%20short%20for%20DID,push%20notifications%2C%20and%20QR%20codes)). It supports offline messaging via mediators ([Guest Blog: DIDComm Demo](https://blog.identity.foundation/dif-guest-blog-didcomm-demo/#:~:text=DIDComm%20doesn%E2%80%99t%20provide%20an%20inherent,to%20be%20stored%20and%20routed)) and can handle multi-party interactions. The main drawbacks are its potential reliance on a stable mediator endpoint (which must be kept censorship-resistant) and the complexity of implementation. It fulfills all requirements, though with more overhead in deployment.

### Lightning Onion Messages  

The Lightning Network (LN) is a peer-to-peer network for Bitcoin micropayments, but it also supports sending arbitrary messages through the same onion-routed mechanism used for payments. **Onion messages** (as defined in LN’s BOLT #7 updates) allow a node to send an encrypted message that gets routed through Lightning nodes to a destination node without creating a visible on-chain trace ([Onion messages | Bitcoin Optech](https://bitcoinops.org/en/topics/onion-messages/#:~:text=Onion%20messages%20are%20messages%20that,use%20of%20LN%20node%20resources)). They piggyback on the LN channel network, using the same Sphinx onion encryption scheme as payments, but do not require an actual payment (thus no fees, or negligible ones). For Beacon coordination, if each DID controller operates a Lightning node (or has access to one), they could communicate by sending onion messages to each other’s LN node public keys.

- **Privacy & Encryption:** **Excellent (network-level).** Onion messages are routed just like Lightning payments: each hop only knows the next hop, and the content is layered in encryption (onion) such that no intermediate can read it ([Bitcoin Optech Newsletter #306 Recap Podcast | Bitcoin Optech](https://bitcoinops.org/en/podcast/2024/06/11/#:~:text=already%20running%20Lightning%20nodes%20are,they%20sent%20the%20message%20to)). The originator’s identity is *mostly hidden*: the recipient can’t directly tell which node originated the message, only that it came via some route (there are some nuances – the last hop sees the second-to-last hop’s identity, but not the origin). As noted in a Bitcoin Optech discussion, you can send a message through LN “*without revealing the sender. The only thing the recipient learns is that someone… sent the message, and they respond back via onion messages not knowing who they responded to*” ([Bitcoin Optech Newsletter #306 Recap Podcast | Bitcoin Optech](https://bitcoinops.org/en/podcast/2024/06/11/#:~:text=already%20running%20Lightning%20nodes%20are,they%20sent%20the%20message%20to)). This is strong **anonymity** for the communicators at the network level. Also, because it doesn’t use the IP-layer identity (everything is via node pubkeys over Tor or other channels), it doesn’t leak IP addresses easily. However, one caveat: the *content* of an onion message, once it reaches the final recipient, is not automatically end-to-end encrypted beyond the onion routing. In other words, the payload inside the onion could be plaintext between the sending and receiving node. If the two DID controllers trust each other’s node identity (which they do, since they’re cohort members), they might be okay with that. But for maximum security, they could additionally encrypt the message content with the recipient’s key (essentially double encryption – one by the onion route, one by the application). That would ensure that even the final recipient’s LN node (if separate from their DID agent) can’t see the message content unless authorized. In summary, LN onion messages provide **excellent privacy against outsiders** – it’s very hard for anyone to trace or eavesdrop on messages in transit – and with optional end-to-end encryption of the payload, you also guarantee content secrecy from the receiving node operator. Lightning’s use of Tor by many nodes (including default in implementations like LND) further enhances anonymity.  
- **Authenticity & Signatures:** By itself, an onion message is just a transport – it does not inherently sign the message on behalf of the sender’s identity. The recipient will know a message was delivered to them, but unless the content carries a signature or identifier, they might not know which cohort member sent it. In the Beacon context, participants would likely embed their DID or a signature inside the message payload to indicate the sender. Since the group already shares context (they expect messages from the known *n* controllers), they could sign each payload with their DID key to authenticate it, or even rely on the nature of the content (e.g., a partial signature on a transaction is implicitly tied to a specific key). In practice, it would be wise to include a digital signature or MAC in the message so the recipient can be sure it was composed by the claimed sender and not altered. Lightning nodes themselves authenticate at the connection level (node pubkeys authenticate channel connections), but that doesn’t automatically translate to application-level authenticity. So, compared to Nostr or DIDComm which have built-in signing, LN onion messages need an **explicit signing step for content**. Fortunately, doing so is straightforward (the participants have keys). This approach would give authenticity and integrity. On a related note, since LN messages target a node pubkey, you do ensure the message is delivered to the correct entity (assuming the DID controller’s Lightning node pubkey is known). But if a malicious party somehow injected messages, without the proper signature the group can ignore them. In short, **authenticity can be achieved** but is not intrinsically guaranteed by the onion routing itself – you have to add it via signatures in the protocol.  
- **Censorship Resistance:** **High.** The Lightning Network is a decentralized network of nodes with no central authority controlling routes. To censor onion messages, an adversary would effectively need to control a majority of the network or specifically target the channels between the communicating nodes. Since onion messages use the same paths as payments, any attempt to wholesale censor them would likely involve shutting down or blacklisting many Lightning nodes – which is impractical on a large scale. Additionally, onion messages are end-to-end encrypted and *indistinguishable from normal payment traffic* (except there’s no payment attached), so it’s hard for intermediate nodes to even know they are relaying a “Beacon coordination message” as opposed to some LN protocol message. The Lightning network’s reliance on pseudonymous node pubkeys and often Tor transport makes it resilient to state-level censorship (you’d have to block all Tor or all lightning traffic, which is broad). However, one point of failure could be if *all participants rely on a specific Lightning service provider*: for instance, if everyone was on the same Lightning hub and that hub censored messages. But in a truly decentralized setup, each runs their own node or at least connects to the network at large. Thus, onion messaging inherits Lightning’s censorship resistance. It’s worth noting that Lightning is not as widely accessible as the base internet (one needs to be on the LN), but within that realm, it’s quite censorship-resistant. **Bottom line:** as long as participants maintain connectivity in the LN, their messages should get through without any central party able to block them.  
- **Scalability & Performance:** Lightning onion messages are very fast – they are routed within milliseconds to a few seconds across the network, typically much faster than block confirmations or even some internet requests (because many LN nodes have low-latency connections). For interactive signing, this low latency is appealing. The protocol overhead is minimal beyond cryptographic onion wrapping. In terms of scalability, onion messages don’t use HTLCs, so they don’t consume channel capacity or on-chain transactions ([Onion messages | Bitcoin Optech](https://bitcoinops.org/en/topics/onion-messages/#:~:text=Onion%20messages%20are%20messages%20that,use%20of%20LN%20node%20resources)). They do, however, consume bandwidth and a bit of CPU on each routing node. If Beacon signals were very frequent or large, this could raise concerns, but the expected usage (infrequent DID updates) is negligible in volume. One limitation to highlight: Lightning is a **real-time network**. It does not store messages – if a recipient’s node is offline, the message attempt fails to deliver. There is currently no guaranteed store-and-forward within LN (though proposals exist to “wake offline nodes” with push notifications ([Onion messages | Bitcoin Optech](https://bitcoinops.org/en/topics/onion-messages/#:~:text=2024))). This means for *asynchronous* coordination, LN alone is problematic. All parties need to be online at roughly the same time to do a signing round. If a node is offline, the sender would have to retry later (or the group must wait). This lack of offline delivery is a significant drawback relative to Nostr, DIDComm, or Matrix. Solutions might involve using a watchtower or an always-online proxy node for each participant to catch messages, but that reintroduces a semi-central dependency. So, performance is great **when online**, but **offline support is poor** – Lightning onion messaging is essentially synchronous. For scalability in number of participants, Lightning can route to thousands of nodes, but each new unique route might require network gossip to know how to reach them, etc. In small *n* cases, that’s trivial. Summarily, **high performance**, but does not natively meet the offline/asynchronous requirement.  
- **Self-Sovereignty & Openness:** **High.** Running a Lightning node is an act of self-sovereignty in the Bitcoin world – you control your channels and keys. The onion message feature comes as part of the open LN protocol (BOLTs are publicly specified, open source implementations). There’s no reliance on centralized servers; each participant either runs their own node or at least uses a non-custodial node that they control keys for. The Lightning protocol itself is open and community-driven. One nuance: if participants already run Lightning nodes (perhaps for other reasons), this is a very *natural* extension. If they do not, adopting LN just for messaging is a heavy lift. But assuming they do, they aren’t beholden to any third party for this communication. Channels used for routing are between consenting peers; if one route fails, the network finds another. Lightning’s design is about removing central points of failure (except perhaps reliance on the Bitcoin network at the base layer, but that’s a given in this context). In terms of openness: anyone can join the LN by opening a channel, so new DID controllers can integrate without permission. Overall, Lightning onion messaging scores high on self-sovereignty—**provided** each DID controller is comfortable being their own Lightning node operator.  
- **Ease of Implementation:** **Low.** Using Lightning for messaging is on the complex end. Each controller must either run a full LN node (LND, c-lightning, Eclair, etc.) or depend on one. Setting up a Lightning node involves syncing the Bitcoin blockchain (or at least using a light client mode), managing channels and liquidity (though for messages, even 0-value channels could work), and dealing with node connectivity. From a software integration standpoint, one would use the Lightning implementation’s API (e.g., `sendOnionMessage` in Core Lightning or LND’s equivalent). At the moment (circa 2025), onion messaging is a relatively new feature and might not be available or stable in all LN implementations without toggling experimental options. Documentation is still sparse ([Onion Messaging In Depth. Feedback from Matt Corallo recently… | by Rusty Russell | Medium](https://rusty-lightning.medium.com/onion-messaging-in-depth-d8e384ee4184#:~:text=Feedback%20from%20Matt%20Corallo%20recently,uses%20them%20for%20BOLT%2012)). Developers would need to understand route construction or rely on the node’s internal pathfinding. Additionally, testing and debugging an onion-routed protocol can be challenging, as failures might be silent drops if routes fail. Compared to all other options, this is perhaps the **most complex** to get running, especially if the team’s expertise is not already in Lightning development. There is also a steep operational burden: nodes must be online to receive messages (which might mean cloud-hosting a node or running a server 24/7). In contrast, other solutions allow a more lightweight client that can come online occasionally to fetch messages. Unless the DID method implementers already have Lightning node infrastructure in place, the implementation cost is high. On the plus side, if they do, adding messaging is just an API call away. But overall, this approach is likely the hardest to implement and maintain for our use case.

**Summary:** Lightning onion messages excel in privacy, anonymity, and censorship resistance – they naturally obscure who’s talking to whom ([Bitcoin Optech Newsletter #306 Recap Podcast | Bitcoin Optech](https://bitcoinops.org/en/podcast/2024/06/11/#:~:text=already%20running%20Lightning%20nodes%20are,they%20sent%20the%20message%20to)). However, the requirement of simultaneous online presence and the complexity of running LN nodes make this approach less practical for most DID controller cohorts. It meets many security requirements but **struggles with offline messaging**, a key need for asynchronous coordination. It’s a powerful but specialized solution, likely best if the controllers are already deeply integrated with the Lightning Network.

### Self-Hosted Server / IRC / Matrix (via Tor)  

This category covers a variety of DIY or existing communication channels where the cohort could effectively run their own mini-network or use generic communication tools. Examples include setting up a private server (or forum) for coordination, using an IRC channel or Matrix room for the group, possibly enhanced with Tor hidden services for anonymity. The idea is to leverage general messaging systems in a **self-sovereign** way – e.g., host it themselves and use end-to-end encryption. We consider them together as they share some similar traits (especially when paired with Tor for privacy), though there are differences (Matrix supports built-in E2EE and federation; IRC is old-school and plaintext unless OTR or similar is used).

- **Privacy & Encryption:** **Variable (can be High).** If using Matrix, one can create a private room with **end-to-end encryption enabled** (Matrix uses the Olm/Megolm protocols for group chat encryption). This would ensure only the DID controllers (participants in the room) can read the messages, not even the server operators. Matrix E2EE is well-regarded and on by default for private chats in many clients ([Matrix: secure communication - kernel concepts](https://www.kernelconcepts.de/matrix-secure-communication/?lang=en#:~:text=Matrix%3A%20secure%20communication%20,interoperability)). If using a self-hosted server solution, the team can choose to encrypt message contents at the application level (for instance, exchanging PGP-encrypted payloads via a simple message board). IRC, by default, is not encrypted (and IRC servers see everything), but the group could use an OTR (Off-the-Record) plugin or similar for peer-to-peer encryption. OTR, however, is typically two-party, not multi-party, so group IRC encryption is cumbersome. A simpler approach if on IRC would be each message is individually encrypted to each recipient’s key and posted (not very convenient). Using Tor hidden services adds another layer: Tor would hide IP addresses and make the communication *endpoint anonymous*. For example, a self-hosted web server accessible only via a .onion address means outsiders can’t easily determine who hosts it or who is connecting – all traffic is encrypted in Tor and anonymized. The Tor Project states onion services are one of the most censorship-resistant and private ways to host content (no exit node to spy, end-to-end encrypted within Tor) ([Properties - The Onion Services Ecosystem](https://onionservices.torproject.org/technology/properties/#:~:text=%2A%20It%E2%80%99s%20the%20most%20censorship,is%20reachable%20to%20the%20user)). In summary, this category **can achieve excellent privacy**, but it’s more *roll-your-own*: you must configure and use the available tools correctly. Matrix over Tor, with E2EE on, would be a high-privacy solution (content and metadata both protected to a large extent). A private IRC over Tor with OTR would also be quite private, though harder to set up correctly. One risk in self-hosting: if the server is not well secured, an attacker could break in and read logs or live memory. With strong E2EE, that risk is mitigated.  
- **Authenticity & Signatures:** If Matrix is used with E2EE, authenticity is provided at the protocol level: each user has device keys, and messages include signatures so recipients can be sure which device (which user) sent it (this is how Matrix ensures you’re talking to who you think, assuming you’ve verified their device keys). The **Matrix protocol** thus offers authenticated encryption – you invite specific user IDs (each tied to a key) and after verification, you trust messages indeed come from that user. However, those user IDs might be just usernames on your server unless you map them to real DID identities. The group may still want to exchange and verify an extra layer of signatures: for instance, each could post their MuSig commitments with a signature using their DID key, so that even if someone somehow infiltrated the Matrix room, they couldn’t spoof another. In a self-hosted custom server, authenticity would entirely depend on what you implement – likely the participants would sign each update or use an authenticated channel. IRC has no native auth (anyone can choose a nickname), so you’d rely on perhaps a password-protected channel plus knowing each other’s style, but cryptographic signature on each message is safer. The DID controllers have the keys to do so, so it’s prudent to sign important data anyway. Overall, **authenticity can be ensured** in these channels but largely through the application level. Matrix gets a nod for having a robust identity and verification system (users can verify each other’s keys via SAS codes or QR scans, ensuring the “Alice” in the room is truly Alice) – this is effectively a built-in authenticity if properly used. When these tools are layered with the DID context, one might not fully rely on Matrix/IRC identity alone, but combined with DID signatures, authenticity would be strong.  
- **Censorship Resistance:** **High (if using Tor or decentralized hosting).** A self-hosted solution can be extremely censorship-resistant if done right. For instance, if the cohort runs a Matrix homeserver on a Tor hidden service, there is no DNS to block and no public IP exposed – censors would have trouble even locating the server, let alone blocking it (they’d have to block Tor network access, which is a broad action). Even without Tor, running on a small VPS under the radar might avoid attention, though not guaranteed. IRC networks can be taken down or blocked by governments (some have been), but there are many networks and one can run their own IRC server as well (even on Tor). Matrix is federated, meaning even if you use matrix.org and it bans you, you could host your own or join a different server – similar to email’s federation model, giving some resilience against deplatforming. Self-hosted servers are under the cohort’s control – an external censor would have to locate and attack that server specifically. Using hidden services and not advertising it publicly makes it essentially invisible to censors. Historically, Tor hidden services are considered **one of the most censorship-resistant methods** of hosting communications ([Properties - The Onion Services Ecosystem](https://onionservices.torproject.org/technology/properties/#:~:text=%2A%20It%E2%80%99s%20the%20most%20censorship,is%20reachable%20to%20the%20user)). Thus, this approach can fulfill the censorship resistance requirement, with the caveat that if one of the participants is hosting on clearnet, they could be targeted (DDoS or legal orders). To counter that, redundancy or backup channels could be arranged (e.g., if the private server is shut down, fall back to a public Matrix server or an alternate onion). But since the question context is about a method spec, we assume an ideal deployment – and in that case, yes, it can be made highly censorship-resistant.  
- **Scalability & Performance:** For a small group, any of these solutions will perform fine. A single Matrix homeserver can easily handle a handful of users sending occasional messages – it’s designed to scale to thousands of users and rooms. IRC is lightweight and real-time for chat. Even running over Tor, the message latency might be a bit higher (Tor can add a second or two in worst cases), but still reasonable for an interactive signing session. Throughput is not an issue given the low message volumes of Beacon coordination. One consideration: if using federation (multiple Matrix servers, one per user perhaps), messages have to replicate across servers, which adds complexity and slightly more delay, but federation means no single server sees all data (improving decentralization). That’s a trade-off: one could simply all join the same server for simplicity (then performance is like any chat room). Another angle: offline messaging. Matrix supports offline messaging inherently – if one user is offline, the server stores the messages and delivers when they come online (since it’s essentially an inbox for them). IRC, in contrast, does **not** store history by default; if you’re offline, you miss messages (though workarounds exist like using an IRC bouncer or logging bot). So Matrix or a custom web server with a database would better meet the asynchronous requirement than bare IRC. In summary, **performance is ample** and the only limitation might be if one tries to strictly do it with IRC without ensuring presence, which could drop messages. But presumably, the cohort would ensure some persistence (Matrix or logs). Scaling to more controllers or more frequent updates is not a problem – these systems can handle far more load than a DID beacon is likely to generate.  
- **Self-Sovereignty & Openness:** **High.** The protocols suggested (Matrix, IRC) are open and widely used standards. Matrix is open source, specified, and managed by a non-profit foundation; anyone can run a server or write a client ([I'm project lead for Matrix.org, the open protocol for decentralised secure communication - AMA! : r/privacy](https://www.reddit.com/r/privacy/comments/da219t/im_project_lead_for_matrixorg_the_open_protocol/#:~:text=Hi%2C%20I%E2%80%99m%20Matthew%3B%20the%20project,org)). IRC is an old open protocol with many implementations. Both allow running your own server, which is the ultimate self-sovereign move for communication – you’re not depending on a corporation’s platform. By using Tor hidden services for access, you remove reliance on domain registrars or certificate authorities. In effect, the group creates a mini-private network on their own terms. This is very much in line with decentralization: it’s not globally decentralized like Nostr, but it *is* locally decentralized (the control rests with the participants). One participant (or all, if federating) will operate the infrastructure. Provided everyone trusts each other in that regard (or they share operation responsibilities), this is quite sovereign. Openness also means interoperability – Matrix clients are numerous (so each can use one they like), IRC clients too. No proprietary tech is being invoked. The only downside is that if only one server is used, that server operator has a bit of power (they could shut it down). But since it’s within the cohort, it’s less of a concern than a third-party provider. The openness of Matrix in particular means it’s extensible (they could even integrate bot scripts to automate parts of the signing workflow in the chat). In conclusion, this approach can be executed in a way that **keeps the power in the hands of the DID controllers** entirely.  
- **Ease of Implementation:** **Moderate.** This is somewhat a mix-and-match solution. Using Matrix as an example: one could simply create a private room on an existing Matrix server (like matrix.org), invite the others, and turn on encryption. That is very easy (just like using a messaging app) – however, that relies on a public server which might not be ideal for privacy or censorship (Matrix.org could theoretically see metadata or refuse service). A more self-sovereign route is to set up a Matrix server (e.g., Synapse). Setting up Synapse is well documented but does require system administration work. Likewise, setting up an IRC server (like UnrealIRCd or ngircd) is not too hard, but one must secure it and possibly set up an OTR enforcement. Using Tor adds another layer: configuring the service to listen on an onion address – again, well-documented but technical. In terms of client integration: if the DID coordination software is not going to have the user manually use an IRC client or Element (Matrix client), it might need to programmatically interface. Matrix has client libraries (Matrix SDKs) which could be used so the agent software itself joins the room and exchanges messages. That’s extra coding but feasible (Matrix APIs are modern JSON over HTTPS). IRC also has libraries but dealing with encryption on IRC might force using an external OTR library or implementing an encryption scheme on top of messages. If the coordination is semi-manual (i.e., users just use a chat app to coordinate), then implementation is trivial but user experience might suffer. If it’s automated, then moderate coding is required. Overall, it’s easier than implementing DIDComm from scratch, but harder than using Nostr or a simple REST because you either rely on external software or need to embed a chat protocol library. The **easiest** in this category might be to use a Matrix room on a public server as a quick solution, but to meet all requirements in spirit, running it over Tor on your own server is the ideal – which is a moderate DevOps project. Many guides exist (Matrix over Tor is known in the privacy community). So we can call this **medium ease** – not overly hard for those familiar with running services, but certainly requires more effort than point-and-click solutions.

**Summary:** A self-hosted or P2P chat solution gives the cohort a lot of control. By leveraging mature protocols like Matrix (with E2EE) and Tor’s anonymity ([Properties - The Onion Services Ecosystem](https://onionservices.torproject.org/technology/properties/#:~:text=%2A%20It%E2%80%99s%20the%20most%20censorship,is%20reachable%20to%20the%20user)), they can achieve privacy and censorship-resistance comparable to the other options. The trade-off is the onus is on them to set it up and maintain it. It checks the requirement boxes (secure, offline capable, decentralized if federated or at least not third-party) and might integrate well enough. It’s a solid approach if the group is willing to manage custom infrastructure or already has a private communication server.

## Comparison of Protocols by Attribute

The following table summarizes how each protocol fares with respect to the six key attributes, based on the analysis above:

| **Protocol**                | **Privacy & Encryption** | **Authenticity & Signatures** | **Censorship Resistance** | **Scalability & Performance** | **Self-Sovereignty & Openness** | **Ease of Implementation** |
|-----------------------------|--------------------------|-------------------------------|---------------------------|-------------------------------|-------------------------------|---------------------------|
| **REST (HTTPS)**            | **Low–Moderate.** Encrypted in transit via TLS, but not E2E by default; server sees plaintext without extra encryption. Metadata (IP/domain) visible ([Internet censorship - Wikipedia](https://en.wikipedia.org/wiki/Internet_censorship#:~:text=The%20use%20of%20HTTPS%20does,depends%20on%20both%20client%20and)). Requires custom payload encryption for strong privacy. | **Moderate.** Relies on TLS for server auth; no built-in message signing. Must add signatures at application level to verify origin and integrity. | **Low.** Centralized endpoints easily blocked (DNS/IP filtering) ([Internet censorship - Wikipedia](https://en.wikipedia.org/wiki/Internet_censorship#:~:text=The%20use%20of%20HTTPS%20does,depends%20on%20both%20client%20and)). Single server or domain can be shut down or censored, unless each participant self-hosts (which is complex to coordinate). | **High.** HTTP is lightweight and fast for small groups. Handles interactive rounds with low latency. Store-and-forward needs custom coding (database or polling) for offline support. | **Moderate.** Open standards (HTTP, TLS) but typically involves central servers or DNS – not peer-to-peer. Controllers can self-host, but coordination still tends toward a hub model. | **High (Easy).** Very familiar tech (REST APIs, JSON). Many tools and libraries. Minimal new learning, but does require running a web server and ensuring availability. Little automation for P2P without central server. |
| **Nostr**                   | **High.** Content can be end-to-end encrypted (use of kind-4 direct or kind-14 group messages) so only intended recipients decrypt ([The Nostr Privacy Paradox](https://bitcoinmagazine.com/technical/how-nostr-can-improve-bitcoin-privacy#:~:text=Instead%20of%20using%20notification%20transactions,through%20the%20avoidance%20of%20toxic)). Identities are pseudonymous pubkeys. Publishing via multiple relays adds metadata privacy (no single ISP sees all). | **High.** All messages/events are signed by the sender’s private key ([Nostr, a simple protocol for decentralizing social media that has a chance of working](https://nostr.com/#:~:text=Resilient)), ensuring authenticity and integrity. Each controller’s pubkey is known to others, so impostor messages are rejected. | **Very High.** Designed for censorship resistance – decentralized network of relays, no single point of failure ([Nostr, a simple protocol for decentralizing social media that has a chance of working](https://nostr.com/#:~:text=Nostr%20is%20a%20simple%2C%20open,resistant%20social%20media)). Users can publish to many relays; no one can universally block an event. Relays can’t alter content (signatures validate that) ([Nostr - Wikipedia](https://en.wikipedia.org/wiki/Nostr#:~:text=protocol%20achieves%20decentralization%20through%20users,3)). | **High.** Scales to global use. Efficient publish/subscribe for group messages. Relays store messages for offline users ([The Nostr Privacy Paradox](https://bitcoinmagazine.com/technical/how-nostr-can-improve-bitcoin-privacy#:~:text=The%20problem%3A%20PayJoin%20transactions%20are,By%20using%20Nostr%20keys%20instead)). Low latency (usually sub-second) for online peers. Slight overhead if encrypting separately to each recipient, but trivial for small n. | **High.** Completely open protocol (anyone can run relays or clients). Self-sovereign identities (keys) – no authority needed. No DNS or CA dependence; can even use relays over Tor. Very much in line with decentralized principles. | **Moderate.** Simpler than DIDComm, with many client libraries available. However, group encryption is not default – requires using NIP-04/44 (DM encryption) for each recipient or new group chat NIPs. Developers must handle relay connectivity. Overall reasonably easy given community support, but some crypto handling needed. |
| **DIDComm (v2)**            | **High.** Built-in end-to-end encryption of messages using DID keys ([Guest Blog: DIDComm Demo](https://blog.identity.foundation/dif-guest-blog-didcomm-demo/#:~:text=DIDComm%20is%20short%20for%20DID,push%20notifications%2C%20and%20QR%20codes)). Only intended recipients can decrypt. Mediators can’t read content (they see only ciphertext). Strong privacy and even forward secrecy depending on config. | **High.** Supports signed messages – sender can sign with their DID private key, and recipients verify via DID Document ([Guest Blog: DIDComm Demo](https://blog.identity.foundation/dif-guest-blog-didcomm-demo/#:~:text=DIDComm%20uses%20did%3Apeer2%20DIDs%20to,Demo%20app%20resolves%20the%20mediator%E2%80%99s)). Authenticity and integrity are assured. Even without explicit signature, authenticated encryption can confirm sender’s identity. | **Moderate.** No global infrastructure – depends on chosen transport. Can be resistant if used P2P or over Tor, but a single mediator endpoint could be blocked. Flexibility to route via email, Tor, etc., mitigates some censorship. Essentially as censor-resistant as the underlying channels (which can be chosen for resilience). | **Moderate.** Technically efficient (small JSON, supports multi-party encryption), but multi-recipient messaging may require sending multiple copies. Mediator enables offline storage ([Guest Blog: DIDComm Demo](https://blog.identity.foundation/dif-guest-blog-didcomm-demo/#:~:text=DIDComm%20doesn%E2%80%99t%20provide%20an%20inherent,to%20be%20stored%20and%20routed)) for async delivery. Good for interactive protocols, though slightly more latency if using store-and-forward. Scales well for the typical cohort size (not heavy global use). | **High.** Open standard from DIF/IETF. Peer-to-peer ethos – no central server required (each DID can define its own service endpoint). Aligns with self-sovereign identity (everyone uses their own DID and keys). Interoperable across vendors. | **Low.** Complex to implement from scratch. Requires handling DID resolution, message packing/encryption, and possibly running a mediator service. Libraries exist but can be heavy. Higher development and integration effort to get it working compared to other options. |
| **Lightning Onion Msgs**    | **High.** Onion routing provides strong privacy: intermediate nodes can’t read content and don’t know source or destination ([Bitcoin Optech Newsletter #306 Recap Podcast | Bitcoin Optech](<https://bitcoinops.org/en/podcast/2024/06/11/#:~:text=already%20running%20Lightning%20nodes%20are,they%20sent%20the%20message%20to>)). Sender’s identity is concealed from recipient (unless revealed in content). However, content at final node is plaintext by default – recommend extra encryption in payload for true E2E secrecy. | **Moderate.** Transport doesn’t include sender’s signature. Recipient knows the message came through LN, but must trust content or require an in-message signature to verify which cohort member sent it. Authenticity achievable by signing the payload with DID keys. Without that, there’s a slight gap since LN only authenticates hops, not the end-to-end origin. | **High.** Very hard to censor. No centralized servers – messages route through the LN peer graph. Looks like normal LN traffic (encrypted packets), so censors can’t easily distinguish it. To censor, one would need to shut down large parts of the LN or block Tor (many LN nodes use Tor). | **High (online)** / **Low (offline).** Lightning is real-time; messages deliver quickly if nodes are online. Excellent latency for interactive rounds. Network can handle many messages, though primarily designed for payments (onion messages have negligible overhead). **Offline is a problem:** if a node is down, message delivery fails (no storing). All parties likely need to be online simultaneously, or implement custom retry logic. | **High.** Decentralized and open (part of Lightning spec). Participants control their own nodes and keys – no reliance on third-party infrastructure. Truly peer-to-peer via the Bitcoin Lightning network. (However, requiring each to run a LN node is a heavy prerequisite, which affects practicality but not the theoretical openness). | **Low.** Difficult to implement and maintain. Needs running Lightning nodes and using LN protocol calls. Onion message feature is new and not widely turnkey – may require enabling experimental features ([Onion Messaging In Depth. Feedback from Matt Corallo recently… | by Rusty Russell | Medium](<https://rusty-lightning.medium.com/onion-messaging-in-depth-d8e384ee4184#:~:text=Feedback%20from%20Matt%20Corallo%20recently,uses%20them%20for%20BOLT%2012>)). Complex networking (channels, liquidity not needed for messaging but node must be part of network). High technical bar for setup compared to others. |
| **Self-Hosted / IRC / Matrix** | **High (if configured).** Can achieve strong privacy with the right setup. Matrix supports end-to-end encrypted rooms (only members read messages) ([Matrix: secure communication - kernel concepts](https://www.kernelconcepts.de/matrix-secure-communication/?lang=en#:~:text=Matrix%3A%20secure%20communication%20,interoperability)). A self-hosted server on a Tor .onion hides participant IPs and resists eavesdropping ([Properties - The Onion Services Ecosystem](https://onionservices.torproject.org/technology/properties/#:~:text=%2A%20It%E2%80%99s%20the%20most%20censorship,is%20reachable%20to%20the%20user)). IRC alone is not secure, but adding OTR encryption or tunneling over Tor can provide privacy. Ultimately, content can be confidential and network metadata obscured, but it’s manual to set up. | **Moderate–High.** Depends on solution. Matrix E2EE provides authentication (users verify identity keys, and messages are signed/encrypted per that) – so you know which user (which DID controller, if mapped) sent each message. In custom setups or IRC, you’d need to include digital signatures in messages for strong authenticity. It’s achievable (sign each coordination message with DID key), but not automatic. | **High.** Self-hosting via Tor makes it extremely censorship-resistant (hidden services are hard to block) ([Properties - The Onion Services Ecosystem](https://onionservices.torproject.org/technology/properties/#:~:text=%2A%20It%E2%80%99s%20the%20most%20censorship,is%20reachable%20to%20the%20user)). Even on clearnet, a private server is not easily discovered by censors. Matrix federation means if one server is shut down, others still have the data. IRC networks can be blocked, but running your own or using alternative networks via Tor circumvents that. Essentially, the group has full control over hosting, so external censorship is difficult unless the whole Tor network or similar is blocked. | **Moderate.** For a small cohort, performance is fine. Matrix is efficient for messaging (though heavier than pure P2P). Tor may add some latency, but signing protocols would still complete in acceptable timeframes (slightly slower but workable). Offline messaging is supported in Matrix (server stores until retrieved) and in any custom server with a database. IRC lacks offline storage by default (unless using bots or bouncers to log messages). So, if using Matrix or a web server, asynchronous coordination is solved; if using bare IRC, all must be present or risk missed messages. | **High.** Uses open protocols (Matrix, IRC) and/or self-run infrastructure. The group isn’t beholden to a corporation – they can run their own server and even federate if desired. All software involved is open source. Identities can be self-managed (you create your user accounts or aliases). It’s as sovereign as the effort you put in (the group could even collectively run the server). No inherent centralization except what the group chooses (if one hosts for all, that person is a local central point – but not a third-party). | **Moderate.** Not as plug-and-play as using an existing platform, but not too onerous. Setting up a Matrix server and managing keys requires some sysadmin work. Alternatively, using an existing Matrix service is easy but less self-sovereign. IRC approach might require custom encryption tooling. Integration into automated workflows may require writing bots or using client APIs (Matrix has client SDKs). Overall, some assembly required – easier than implementing a new protocol from scratch, but it involves configuring and maintaining services. |

## Recommendation  

Considering all factors, **Nostr** emerges as the most well-rounded choice for supporting SMTAggregate and CIDAggregate Beacon coordination in the did:btc1 method. It best fulfills *all* the requirements in combination:

- **Decentralized coordination:** Nostr has no central server – DID controllers can coordinate by sharing events via multiple relays, ensuring no single point of control or failure ([Nostr, a simple protocol for decentralizing social media that has a chance of working](https://nostr.com/#:~:text=Nostr%20is%20a%20simple%2C%20open,resistant%20social%20media)). Each participant operates with their own key, and they can even run their own relays if needed, achieving a high degree of decentralization.

- **Secure message exchange:** Nostr supports end-to-end encrypted messages for private communication ([The Nostr Privacy Paradox](https://bitcoinmagazine.com/technical/how-nostr-can-improve-bitcoin-privacy#:~:text=Instead%20of%20using%20notification%20transactions,through%20the%20avoidance%20of%20toxic)). By using direct encrypted events (or the newer group chat encryption standards), the cohort can exchange the sensitive data (partial signatures, new public keys, etc.) confidentially. Meanwhile, Nostr’s inherent signing of all messages guarantees authenticity – every message can be verified as coming from a known DID controller’s key ([Nostr, a simple protocol for decentralizing social media that has a chance of working](https://nostr.com/#:~:text=Resilient)). This covers both confidentiality and integrity in the communications.

- **Offline/asynchronous capabilities:** Nostr is built for asynchronous messaging. Relays store events, allowing participants who come online later to retrieve what they missed ([The Nostr Privacy Paradox](https://bitcoinmagazine.com/technical/how-nostr-can-improve-bitcoin-privacy#:~:text=The%20problem%3A%20PayJoin%20transactions%20are,By%20using%20Nostr%20keys%20instead)). This means a signing round can be initiated by one controller and others can respond when available, rather than requiring all to be simultaneously connected (unlike Lightning’s real-time requirement). This store-and-forward model is essential for a robust threshold signing flow where network or schedule might not align perfectly each time.

- **Threshold signature–friendly workflow:** The interactive nature of MuSig2/FROST (commitments and responses) fits well into Nostr’s publish/subscribe pattern. One controller can publish a commitment, all others listening will receive it, they can each publish their commitments, and so on. The low latency and distributed nature means the protocol rounds can complete quickly when everyone is online, but if someone is delayed, the messages await them. Furthermore, Nostr being based on Schnorr (secp256k1) keys means participants could even choose to use the same keys for Nostr and signing (though that’s optional). The signing workflow can be orchestrated through a known Nostr channel (e.g., using a specific event kind or tag to identify the Beacon session) without requiring a custom communication stack.

In comparison, while **DIDComm** satisfies the security requirements and aligns with DID usage, it adds considerable complexity and may rely on less censorship-resistant channels (like a static mediator service). Nostr achieves similar security outcomes (with proper use of encryption) but in a far more **lightweight and censorship-resistant** way – it was literally designed to ensure information can flow even under adverse conditions ([Nostr: learn about the censorship-resistant “X”! - Area Bitcoin](https://blog.areabitcoin.co/nostr/#:~:text=Nostr%20is%20an%20open,and%20ensuring%20resistance%20to%20censorship)).

**Lightning onion messages**, though very private, fail the offline requirement (and demand that each DID controller runs a Lightning node, which is a high barrier). **REST/HTTPS**, even if easiest, falls short on decentralization and censorship resistance, which are paramount for did:btc1’s philosophy of censorship-resistance ([did_btc1_DID_Method_Specification.pdf](file://file-XHwNKmkiZa9XwqLzWhS2tS#:~:text=did%3Abtc1%20is%20created%20for%20those,wish%20to%20have%20it%20all)). **Self-hosted Matrix/IRC** could work with enough effort, but essentially one would be building a custom version of what Nostr already provides globally – and Nostr’s network effects and existing infrastructure mean less maintenance burden on the DID method implementers.

By choosing Nostr, the did:btc1 method can leverage an *open, already widely-deployed network* for coordination, allowing DID controllers to remain self-sovereign (each has their own key, no dependence on a single server) and secure in their communications. The controllers can broadcast their intent to form a Beacon, exchange the MuSig aggregated public key, and coordinate each Bitcoin transaction update through Nostr with minimal overhead and maximal resilience. In fact, Nostr’s growing adoption in the Bitcoin ecosystem (even used for things like wallet-to-wallet communication and trading signals) indicates good compatibility and support.

**Recommendation:** Implement the Beacon coordination messaging using **Nostr**, with all sensitive data exchanged via Nostr events encrypted to the cohort’s keys. This approach scores “high” across all evaluated attributes – privacy (E2EE), authenticity (signatures), censorship resistance (decentralized relays), scalability (efficient and already proven at scale), openness (anyone can participate, no central control), and relative ease (numerous libraries and existing usage patterns). It provides a secure and robust foundation for multi-party coordination without imposing undue complexity on users or developers.

By adopting Nostr for DID controller coordination, the did:btc1 method ensures that even a group of controllers scattered across the globe can seamlessly come together to manage their decentralized identifier, confident that their coordination channel is private, authenticated, resilient to disruption, and entirely in line with the self-sovereign and censorship-resistant goals of the did:btc1 system ([did_btc1_DID_Method_Specification.pdf](file://file-XHwNKmkiZa9XwqLzWhS2tS#:~:text=did%3Abtc1%20is%20created%20for%20those,wish%20to%20have%20it%20all)).

**Sources:** The analysis above draws on the did:btc1 specification and documentation of each protocol’s capabilities, including Nostr’s design for censorship-resistance ([Nostr, a simple protocol for decentralizing social media that has a chance of working](https://nostr.com/#:~:text=Nostr%20is%20a%20simple%2C%20open,resistant%20social%20media)) and encryption ([The Nostr Privacy Paradox](https://bitcoinmagazine.com/technical/how-nostr-can-improve-bitcoin-privacy#:~:text=Instead%20of%20using%20notification%20transactions,through%20the%20avoidance%20of%20toxic)), DIDComm’s secure messaging framework ([Guest Blog: DIDComm Demo](https://blog.identity.foundation/dif-guest-blog-didcomm-demo/#:~:text=DIDComm%20is%20short%20for%20DID,push%20notifications%2C%20and%20QR%20codes)) ([Guest Blog: DIDComm Demo](https://blog.identity.foundation/dif-guest-blog-didcomm-demo/#:~:text=DIDComm%20doesn%E2%80%99t%20provide%20an%20inherent,to%20be%20stored%20and%20routed)), Lightning’s onion routing privacy ([Bitcoin Optech Newsletter #306 Recap Podcast | Bitcoin Optech](https://bitcoinops.org/en/podcast/2024/06/11/#:~:text=already%20running%20Lightning%20nodes%20are,they%20sent%20the%20message%20to)), and real-world considerations from the Tor Project on onion services ([Properties - The Onion Services Ecosystem](https://onionservices.torproject.org/technology/properties/#:~:text=%2A%20It%E2%80%99s%20the%20most%20censorship,is%20reachable%20to%20the%20user)) and Matrix’s security model ([I'm project lead for Matrix.org, the open protocol for decentralised secure communication - AMA! : r/privacy](https://www.reddit.com/r/privacy/comments/da219t/im_project_lead_for_matrixorg_the_open_protocol/#:~:text=Hi%2C%20I%E2%80%99m%20Matthew%3B%20the%20project,org)). These sources and others are cited inline to substantiate each point. The comparison reflects the state of protocols as of 2025 and the requirements of threshold signature coordination in the did:btc1 context. Each protocol was measured against the core needs of Beacon establishment and signaling, and Nostr best meets the **aggregate of all criteria** to empower decentralized and secure DID controller collaboration. ([Nostr, a simple protocol for decentralizing social media that has a chance of working](https://nostr.com/#:~:text=Nostr%20is%20a%20simple%2C%20open,resistant%20social%20media)) ([The Nostr Privacy Paradox](https://bitcoinmagazine.com/technical/how-nostr-can-improve-bitcoin-privacy#:~:text=Instead%20of%20using%20notification%20transactions,through%20the%20avoidance%20of%20toxic))
